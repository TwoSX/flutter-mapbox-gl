// This file is generated by
// ./scripts/lib/generate.dart
package com.mapbox.mapboxgl

import com.google.gson.JsonParser
import com.mapbox.mapboxgl.Convert.toMap
import com.mapbox.maps.extension.style.layers.properties.PropertyValue

internal object LayerPropertyConverter {
    @JvmStatic
    fun interpretSymbolLayerProperties(o: Any?): Array<PropertyValue<*>?> {
        val data = toMap(o!!) as Map<String?, String?>
        val properties: MutableList<PropertyValue<*>?> = mutableListOf()
        for ((key, value) in data) {
            val jsonElement = JsonParser.parseString(value)
//            val expression = Expression.Converter.convert(jsonElement)
//            when (key) {
//                "icon-opacity" -> properties.add(PropertyFactory.iconOpacity(expression))
//                "icon-color" -> properties.add(PropertyFactory.iconColor(expression))
//                "icon-halo-color" -> properties.add(PropertyFactory.iconHaloColor(expression))
//                "icon-halo-width" -> properties.add(PropertyFactory.iconHaloWidth(expression))
//                "icon-halo-blur" -> properties.add(PropertyFactory.iconHaloBlur(expression))
//                "icon-translate" -> properties.add(PropertyFactory.iconTranslate(expression))
//                "icon-translate-anchor" -> properties.add(
//                    PropertyFactory.iconTranslateAnchor(
//                        expression
//                    )
//                )
//                "text-opacity" -> properties.add(PropertyFactory.textOpacity(expression))
//                "text-color" -> properties.add(PropertyFactory.textColor(expression))
//                "text-halo-color" -> properties.add(PropertyFactory.textHaloColor(expression))
//                "text-halo-width" -> properties.add(PropertyFactory.textHaloWidth(expression))
//                "text-halo-blur" -> properties.add(PropertyFactory.textHaloBlur(expression))
//                "text-translate" -> properties.add(PropertyFactory.textTranslate(expression))
//                "text-translate-anchor" -> properties.add(
//                    PropertyFactory.textTranslateAnchor(
//                        expression
//                    )
//                )
//                "symbol-placement" -> properties.add(PropertyFactory.symbolPlacement(expression))
//                "symbol-spacing" -> properties.add(PropertyFactory.symbolSpacing(expression))
//                "symbol-avoid-edges" -> properties.add(PropertyFactory.symbolAvoidEdges(expression))
//                "symbol-sort-key" -> properties.add(PropertyFactory.symbolSortKey(expression))
//                "symbol-z-order" -> properties.add(PropertyFactory.symbolZOrder(expression))
//                "icon-allow-overlap" -> properties.add(PropertyFactory.iconAllowOverlap(expression))
//                "icon-ignore-placement" -> properties.add(
//                    PropertyFactory.iconIgnorePlacement(
//                        expression
//                    )
//                )
//                "icon-optional" -> properties.add(PropertyFactory.iconOptional(expression))
//                "icon-rotation-alignment" -> properties.add(
//                    PropertyFactory.iconRotationAlignment(
//                        expression
//                    )
//                )
//                "icon-size" -> properties.add(PropertyFactory.iconSize(expression))
//                "icon-text-fit" -> properties.add(PropertyFactory.iconTextFit(expression))
//                "icon-text-fit-padding" -> properties.add(
//                    PropertyFactory.iconTextFitPadding(
//                        expression
//                    )
//                )
//                "icon-image" -> if (jsonElement.isJsonPrimitive && jsonElement.asJsonPrimitive.isString) {
//                    properties.add(PropertyFactory.iconImage(jsonElement.asString))
//                } else {
//                    properties.add(PropertyFactory.iconImage(expression))
//                }
//                "icon-rotate" -> properties.add(PropertyFactory.iconRotate(expression))
//                "icon-padding" -> properties.add(PropertyFactory.iconPadding(expression))
//                "icon-keep-upright" -> properties.add(PropertyFactory.iconKeepUpright(expression))
//                "icon-offset" -> properties.add(PropertyFactory.iconOffset(expression))
//                "icon-anchor" -> properties.add(PropertyFactory.iconAnchor(expression))
//                "icon-pitch-alignment" -> properties.add(
//                    PropertyFactory.iconPitchAlignment(
//                        expression
//                    )
//                )
//                "text-pitch-alignment" -> properties.add(
//                    PropertyFactory.textPitchAlignment(
//                        expression
//                    )
//                )
//                "text-rotation-alignment" -> properties.add(
//                    PropertyFactory.textRotationAlignment(
//                        expression
//                    )
//                )
//                "text-field" -> properties.add(PropertyFactory.textField(expression))
//                "text-font" -> properties.add(PropertyFactory.textFont(expression))
//                "text-size" -> properties.add(PropertyFactory.textSize(expression))
//                "text-max-width" -> properties.add(PropertyFactory.textMaxWidth(expression))
//                "text-line-height" -> properties.add(PropertyFactory.textLineHeight(expression))
//                "text-letter-spacing" -> properties.add(PropertyFactory.textLetterSpacing(expression))
//                "text-justify" -> properties.add(PropertyFactory.textJustify(expression))
//                "text-radial-offset" -> properties.add(PropertyFactory.textRadialOffset(expression))
//                "text-variable-anchor" -> properties.add(
//                    PropertyFactory.textVariableAnchor(
//                        expression
//                    )
//                )
//                "text-anchor" -> properties.add(PropertyFactory.textAnchor(expression))
//                "text-max-angle" -> properties.add(PropertyFactory.textMaxAngle(expression))
//                "text-writing-mode" -> properties.add(PropertyFactory.textWritingMode(expression))
//                "text-rotate" -> properties.add(PropertyFactory.textRotate(expression))
//                "text-padding" -> properties.add(PropertyFactory.textPadding(expression))
//                "text-keep-upright" -> properties.add(PropertyFactory.textKeepUpright(expression))
//                "text-transform" -> properties.add(PropertyFactory.textTransform(expression))
//                "text-offset" -> properties.add(PropertyFactory.textOffset(expression))
//                "text-allow-overlap" -> properties.add(PropertyFactory.textAllowOverlap(expression))
//                "text-ignore-placement" -> properties.add(
//                    PropertyFactory.textIgnorePlacement(
//                        expression
//                    )
//                )
//                "text-optional" -> properties.add(PropertyFactory.textOptional(expression))
//                "visibility" -> properties.add(
//                    PropertyFactory.visibility(
//                        value
//                    )
//                )
//                else -> {}
//            }
        }
        return properties.toTypedArray()
    }

    @JvmStatic
    fun interpretCircleLayerProperties(o: Any?): Array<PropertyValue<*>?> {
        val data = toMap(o!!) as Map<String?, String?>
        val properties: MutableList<PropertyValue<*>?> = mutableListOf()
//        for ((key, value) in data) {
//            val jsonElement = JsonParser.parseString(value)
//            val expression = Expression.Converter.convert(jsonElement)
//            when (key) {
//                "circle-radius" -> properties.add(PropertyFactory.circleRadius(expression))
//                "circle-color" -> properties.add(PropertyFactory.circleColor(expression))
//                "circle-blur" -> properties.add(PropertyFactory.circleBlur(expression))
//                "circle-opacity" -> properties.add(PropertyFactory.circleOpacity(expression))
//                "circle-translate" -> properties.add(PropertyFactory.circleTranslate(expression))
//                "circle-translate-anchor" -> properties.add(
//                    PropertyFactory.circleTranslateAnchor(
//                        expression
//                    )
//                )
//                "circle-pitch-scale" -> properties.add(PropertyFactory.circlePitchScale(expression))
//                "circle-pitch-alignment" -> properties.add(
//                    PropertyFactory.circlePitchAlignment(
//                        expression
//                    )
//                )
//                "circle-stroke-width" -> properties.add(PropertyFactory.circleStrokeWidth(expression))
//                "circle-stroke-color" -> properties.add(PropertyFactory.circleStrokeColor(expression))
//                "circle-stroke-opacity" -> properties.add(
//                    PropertyFactory.circleStrokeOpacity(
//                        expression
//                    )
//                )
//                "circle-sort-key" -> properties.add(PropertyFactory.circleSortKey(expression))
//                "visibility" -> properties.add(
//                    PropertyFactory.visibility(
//                        value
//                    )
//                )
//                else -> {}
//            }
//        }
        return properties.toTypedArray()
    }

    @JvmStatic
    fun interpretLineLayerProperties(o: Any?): Array<PropertyValue<*>?> {
        val data = toMap(o!!) as Map<String?, String?>
        val properties: MutableList<PropertyValue<*>?> = mutableListOf()
//        for ((key, value) in data) {
//            val jsonElement = JsonParser.parseString(value)
//            val expression = Expression.Converter.convert(jsonElement)
//            when (key) {
//                "line-opacity" -> properties.add(PropertyFactory.lineOpacity(expression))
//                "line-color" -> properties.add(PropertyFactory.lineColor(expression))
//                "line-translate" -> properties.add(PropertyFactory.lineTranslate(expression))
//                "line-translate-anchor" -> properties.add(
//                    PropertyFactory.lineTranslateAnchor(
//                        expression
//                    )
//                )
//                "line-width" -> properties.add(PropertyFactory.lineWidth(expression))
//                "line-gap-width" -> properties.add(PropertyFactory.lineGapWidth(expression))
//                "line-offset" -> properties.add(PropertyFactory.lineOffset(expression))
//                "line-blur" -> properties.add(PropertyFactory.lineBlur(expression))
//                "line-dasharray" -> properties.add(PropertyFactory.lineDasharray(expression))
//                "line-pattern" -> properties.add(PropertyFactory.linePattern(expression))
//                "line-gradient" -> properties.add(PropertyFactory.lineGradient(expression))
//                "line-cap" -> properties.add(PropertyFactory.lineCap(expression))
//                "line-join" -> properties.add(PropertyFactory.lineJoin(expression))
//                "line-miter-limit" -> properties.add(PropertyFactory.lineMiterLimit(expression))
//                "line-round-limit" -> properties.add(PropertyFactory.lineRoundLimit(expression))
//                "line-sort-key" -> properties.add(PropertyFactory.lineSortKey(expression))
//                "visibility" -> properties.add(
//                    PropertyFactory.visibility(
//                        value
//                    )
//                )
//                else -> {}
//            }
//        }
        return properties.toTypedArray()
    }

    @JvmStatic
    fun interpretFillLayerProperties(o: Any?): Array<PropertyValue<*>?> {
        val data = toMap(o!!) as Map<String?, String?>
        val properties: MutableList<PropertyValue<*>?> = arrayListOf()
//        for ((key, value) in data) {
//            val jsonElement = JsonParser.parseString(value)
//            val expression = Expression.Converter.convert(jsonElement)
//            when (key) {
//                "fill-antialias" -> properties.add(PropertyFactory.fillAntialias(expression))
//                "fill-opacity" -> properties.add(PropertyFactory.fillOpacity(expression))
//                "fill-color" -> properties.add(PropertyFactory.fillColor(expression))
//                "fill-outline-color" -> properties.add(PropertyFactory.fillOutlineColor(expression))
//                "fill-translate" -> properties.add(PropertyFactory.fillTranslate(expression))
//                "fill-translate-anchor" -> properties.add(
//                    PropertyFactory.fillTranslateAnchor(
//                        expression
//                    )
//                )
//                "fill-pattern" -> properties.add(PropertyFactory.fillPattern(expression))
//                "fill-sort-key" -> properties.add(PropertyFactory.fillSortKey(expression))
//                "visibility" -> properties.add(
//                    PropertyFactory.visibility(
//                        value
//                    )
//                )
//                else -> {}
//            }
//        }
        return properties.toTypedArray()
    }

    @JvmStatic
    fun interpretRasterLayerProperties(o: Any?): Array<PropertyValue<*>?> {
        val data = toMap(o!!) as Map<String?, String?>
        val properties: MutableList<PropertyValue<*>?> = mutableListOf()
//        for ((key, value) in data) {
//            val jsonElement = JsonParser.parseString(value)
//            val expression = Expression.Converter.convert(jsonElement)
//            when (key) {
//                "raster-opacity" -> properties.add(PropertyFactory.rasterOpacity(expression))
//                "raster-hue-rotate" -> properties.add(PropertyFactory.rasterHueRotate(expression))
//                "raster-brightness-min" -> properties.add(
//                    PropertyFactory.rasterBrightnessMin(
//                        expression
//                    )
//                )
//                "raster-brightness-max" -> properties.add(
//                    PropertyFactory.rasterBrightnessMax(
//                        expression
//                    )
//                )
//                "raster-saturation" -> properties.add(PropertyFactory.rasterSaturation(expression))
//                "raster-contrast" -> properties.add(PropertyFactory.rasterContrast(expression))
//                "raster-resampling" -> properties.add(PropertyFactory.rasterResampling(expression))
//                "raster-fade-duration" -> properties.add(
//                    PropertyFactory.rasterFadeDuration(
//                        expression
//                    )
//                )
//                "visibility" -> properties.add(
//                    PropertyFactory.visibility(
//                        value
//                    )
//                )
//                else -> {}
//            }
//        }
        return properties.toTypedArray()
    }

    @JvmStatic
    fun interpretHillshadeLayerProperties(o: Any?): Array<PropertyValue<*>?> {
        val data = toMap(o!!) as Map<String?, String?>
        val properties: MutableList<PropertyValue<*>?> = mutableListOf()
//        for ((key, value) in data) {
//            val jsonElement = JsonParser.parseString(value)
//            val expression = Expression.Converter.convert(jsonElement)
//            when (key) {
//                "hillshade-illumination-direction" -> properties.add(
//                    PropertyFactory.hillshadeIlluminationDirection(
//                        expression
//                    )
//                )
//                "hillshade-illumination-anchor" -> properties.add(
//                    PropertyFactory.hillshadeIlluminationAnchor(
//                        expression
//                    )
//                )
//                "hillshade-exaggeration" -> properties.add(
//                    PropertyFactory.hillshadeExaggeration(
//                        expression
//                    )
//                )
//                "hillshade-shadow-color" -> properties.add(
//                    PropertyFactory.hillshadeShadowColor(
//                        expression
//                    )
//                )
//                "hillshade-highlight-color" -> properties.add(
//                    PropertyFactory.hillshadeHighlightColor(
//                        expression
//                    )
//                )
//                "hillshade-accent-color" -> properties.add(
//                    PropertyFactory.hillshadeAccentColor(
//                        expression
//                    )
//                )
//                "visibility" -> properties.add(
//                    PropertyFactory.visibility(
//                        value
//                    )
//                )
//                else -> {}
//            }
//        }
        return properties.toTypedArray()
    }
}